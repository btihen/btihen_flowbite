---
layout: post
title:  "Phoenix 1.7 with Ash 2.1"
date:   2022-06-11 01:59:53 +0200
updated:   2022-08-01 01:59:53 +0200
slug: ruby
publish: true
categories: elixir phoenix ash
excerpt: Steps to build a Bridgetown Website / Blogsite
---

I've been curious about the Elixir Ash Framework and had some time.  It looks like it helps create an application framework and has many pre-built common solutions.  Authorization, Queries, Application Structure, etc.

As usual, I struggle with API documentation, and I love tutorials.  So I followed the instructions at:
https://www.ash-hq.org/docs/guides/ash/2.4.1/tutorials/get-started.md#module-docs
and integrated it with the slightly outdated Ash 1.x [slide notes](https://speakerdeck.com/zachsdaniel1/introduction-to-the-ash-framework-elixir-conf-2020?slide=16) from a 2020 ElixirConf talk by Zach Daniel called
[Introduction to the Ash Framework](https://www.youtube.com/watch?v=2U3vQHXCF0s)

Here is what I had to do (learn and adjust) to get up and running.

----------

## Install Phoenix (1.7)

First I wanted to try out the unreleased version of Phoenix - so I followed the pre-release notes at:
* https://github.com/phoenixframework/phoenix/blob/master/installer/README.md
* https://speakerdeck.com/zachsdaniel1/introduction-to-the-ash-framework-elixir-conf-2020?slide=6
```bash
mix archive.uninstall phx_new
git clone https://github.com/phoenixframework/phoenix
cd phoenix/installer
MIX_ENV=prod mix do archive.build, archive.install
cd ../..
mix phx.new helpdesk_phx
cd helpdesk_phx
mix ecto.create
git init
git add .
git commit -m "initial phoenix commit"
```

Now we have a fully functional Phoenix site (that does nothing)

----------

Now let's include the Ash Framework with the goal of leaving Phoenix fully functional and adding Ash.

## Add Ash (2.1)

Let's start by adding Ash to the mix file:
```elixir
# mix.exs
  defp deps do
    [
      {:ash, "~> 2.1"},
      {:ash_phoenix, "~> 1.1"},
      {:ash_postgres, "~> 1.0"},
      # this is a nice touch too if using vs-code and ElixirLs
      {:elixir_sense, github: "elixir-lsp/elixir_sense", only: [:dev, :test]},
      # ...
    ]
  end
```

and we can add these to our .formatter file too:
```elixir
# .formatter.exs
[
  import_deps: [:ecto, :ecto_sql, :phoenix, :ash, :ash_postgres, :ash_postgres],
  #                               add these ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  # ...
]
```

Now we need to install these dependencies (packages) with:
```bash
mix deps.get
```

----------

## Building with Ash

So let's build a `ticket support` system like they do in the tutorial.  We will need users and tickets.

As best as I understand as is organized in `applications` or `modules` in this case `support`

Within these `modules` we have `resources` (or models - in rails).

These `resources` will need to be `registered`.

The `support.ex` file is like an `applicaton.ex` file in normal elixir projects.

Lets start by building Tickets (and the necessary infrastructure `registry.ex` and `support.ex`):
```bash
mkdir -p lib/helpdesk/support/resources && touch $_/ticket.ex
touch lib/helpdesk/support/resources/user.ex
touch lib/helpdesk/support/registry.ex
touch lib/helpdesk/support.ex
```

### Resources (Ticket)

We will start with the most basic possible setup (just tickets and no DB)
```elixir
# lib/helpdesk/support/resources/ticket.ex
defmodule Helpdesk.Support.Ticket do
  # This turns this module into a resource
  use Ash.Resource

  actions do
    # basic actions - these are the building blocks for customized actions
    defaults [:create, :read, :update, :destroy]
  end

  # Attributes are the simple pieces of data that exist on your resource
  attributes do
    # Add an autogenerated UUID primary key called `:id`.
    uuid_primary_key :id
    attribute :subject, :string
  end
end
```

We define what can happen within `actions` - hopefully this is clear that enables us to create, read, update and destroy these resources:
```
  actions do
    defaults [:create, :read, :update, :destroy]
  end
```

We define what the `resource` has for attributes in the `attributes` section.  In Rails these are the model's attributes.

```elixir
  attributes do
    uuid_primary_key :id        # adds a primary key using uuid
    attribute :subject, :string # adds 'subject' to the ticket
  end
```

### Registry

I assume this keeps track of the resources we will be using.

```elixir
# lib/helpdesk/support/registry.ex
defmodule Helpdesk.Support.Registry do
  use Ash.Registry,
    extensions: [
      # This extension adds helpful compile time validations
      Ash.Registry.ResourceValidations
    ]

  entries do
    entry Helpdesk.Support.Ticket
  end
end
```

You can see this will allow us to add validations to our resources (later) in this case we have only registered `ticket` under the `entries`.

### Application API file

This file defines the set of resources that can be used with this API (or more accurately, says where to find the resources to load).  This file is named after the name of the module - in this case `support.ex` (but I wonder why its not called `support_api.ex`).

```elixir
# lib/helpdesk/support.ex
defmodule Helpdesk.Support do
  use Ash.Api

  resources do
    # This defines the set of resources that can be used with this API
    registry Helpdesk.Support.Registry
  end
end
```
----------

### Testing Ash (Tickets)

Let's see if what we built actually works.

We will create a 'ticket' resource and then query for it.

To do this we will need to:
1. build a change-set for the create action (for the Ticket resource)
2. give it the `create!` instruction

To do this we will test within iex:

```elixir
iex -S mix

Helpdesk.Support.Ticket
|> Ash.Changeset.for_create(:create)
|> Helpdesk.Support.create!()
```

Which hopefully returns something like:
```bash
#Helpdesk.Support.Ticket<
  __meta__: #Ecto.Schema.Metadata<:built, "">,
  id: "bcc9729b-7fa2-4e7c-af45-3293be3394ee",
  subject: nil,
  aggregates: %{},
  calculations: %{},
  __order__: nil,
  ...
>
```

Notice that the subject is nil (we aren't yet using validations) and our primary key is a uuid.

### Validations

Let's say we don't want to allow blank Subjects and we want to require a restricted list of statuses.

To prevent blanks in a field we can change the attribute subject to look like:
```elixir
# lib/helpdesk/support/resources/ticket.ex
# ...
  attributes do
    attribute :subject, :string do
      allow_nil? false
    end
    # ...
  end
# ...
```

Now lets add a set of restricted statuses (new, open, closed):
```elixir
# lib/helpdesk/support/resources/ticket.ex
# ...
  attributes do
    attribute :status, :atom do
       constraints [one_of: [:new, :open, :closed]]
       default :new
       allow_nil? false
     end
    # ...
  end
# ...
```

Now the `ticket` file should look like:
```elixir
# lib/helpdesk/support/resources/ticket.ex
defmodule Helpdesk.Support.Ticket do
  # This turns this module into a resource
  use Ash.Resource

  actions do
    # A set of simple actions.
    defaults [:create, :read, :update, :destroy]
  end

  # Attributes are the simple pieces of data that exist on your resource
  attributes do
    # Add an autogenerated UUID primary key called `:id`.
    uuid_primary_key :id

    # Add a string type attribute called `:subject`
    attribute :subject, :string do
      allow_nil? false # Don't allow `nil` values
    end

    # status is either `open` or `closed`. We can add more statuses later
    attribute :status, :atom do
      # restricted list of statuses
      constraints [one_of: [:new, :open, :closed]]
      default :new # default value when none is given
      allow_nil? false # Don't allow `nil` values
    end
  end
end
```

### Custom Action

We want to create a custom `new` ticket action - that will only accept one attribute `subject` - which is also now required (per default all attributes will be accepted).

```elixir
# lib/helpdesk/support/resources/ticket.ex
# ...
  actions do
    # ...
    create :new do
      # By default all attributes are accepted by an action
      accept [:subject] # This action should only accept the subject
    end
    # ...
  end
# ...
```

We also want a `close` action:
```elixir
# lib/helpdesk/support/resources/ticket.ex
# ...
  actions do
    # ...
    update :close do
      accept [] # accept no input here
      change set_attribute(:status, :closed)
    end
    # ...
  end
# ...
```

Now the Ticket file should look like:
```elixir
# lib/helpdesk/support/resources/ticket.ex
defmodule Helpdesk.Support.Ticket do
  # This turns this module into a resource
  use Ash.Resource

  actions do
    # Add a set of simple actions. You'll customize these later.
    defaults [:create, :read, :update, :destroy]

    create :new do
      accept [:subject] # only accept the subject - no other fields
    end

    update :close do
      accept [] # don't accept attributes
      change set_attribute(:status, :closed) # build the change set
    end
  end

    # Attributes are the simple pieces of data that exist on your resource
  attributes do
    # Add an autogenerated UUID primary key called `:id`.
    uuid_primary_key :id

    # Add a string type attribute called `:subject`
    attribute :subject, :string do
      allow_nil? false # Don't allow `nil` values
    end

    # status is either `open` or `closed`. We can add more statuses later
    attribute :status, :atom do
      # restricted list of statuses
      constraints [one_of: [:new, :open, :closed]]
      default :new # default value when none is given
      allow_nil? false # Don't allow `nil` values
    end
  end
end
```

To test this change we need to adjust our change set - if we don't we should get an error:
```elixir
iex -S mix
# just in case iex is already open
recompile()

Helpdesk.Support.Ticket
|> Ash.Changeset.for_create(:new)
|> Helpdesk.Support.create!()

# we should get the error:
** (Ash.Error.Invalid) Input Invalid
* attribute subject is required
# ...
```

To properly create a Ticket now -- the following should work:
```elixir
iex -S mix
# just in case iex is already open
recompile()

ticket = (
  Helpdesk.Support.Ticket
  |> Ash.Changeset.for_create(:new, %{subject: "My mouse won't click!"})
  |> Helpdesk.Support.create!()
)
```
we should get something like (notice we have a subject and it's status is `pending`):
```elixir
#Helpdesk.Support.Ticket<
  __meta__: #Ecto.Schema.Metadata<:loaded, "tickets">,
  id: "b792b4f1-2167-4aa8-b654-4aef4938ba9a",
  subject: "My mouse won't click!",
  status: :new,
  # ...
```

Now let's test the `close` action on our new `ticket`:
```elixir
ticket
|> Ash.Changeset.for_update(:close)
|> Helpdesk.Support.update!()
```

Now our ticket should look like:
```elixir
#Helpdesk.Support.Ticket<
  __meta__: #Ecto.Schema.Metadata<:loaded, "tickets">,
  id: "ccd5af37-7cad-40c5-badd-71d5c67d50a5",
  subject: "My mouse won't click!",
  status: :closed,
  # ...
```

Since we have no storage at the moment we can't query our records.

Try:
```elixir
Helpdesk.Support.read!(Helpdesk.Support.Ticket)
```

You should get an error - that says: 'there is no data to be read for that resource'

Let's enable queries - we need to configure a data layer for these resources

## Ash Data Layer

### Simple Queries

We can add a default `Simple` data layer with the macro: `require Ash.Query`, so if we create some tickets using the script:

```elixir
# Ash.Query is a macro, so it must be required
require Ash.Query

tickets =
  for i <- 0..5 do
    ticket =
      Helpdesk.Support.Ticket
      |> Ash.Changeset.for_create(:open, %{subject: "Issue #{i}"})
      |> Helpdesk.Support.create!()

    if rem(i, 2) == 0 do
      ticket
      |> Ash.Changeset.for_update(:close)
      |> Helpdesk.Support.update!()
    else
      ticket
    end
  end
```

Now we should be able to query and filter our tickets:
```elixir
# Show the tickets where the subject contains "2"
Helpdesk.Support.Ticket
|> Ash.Query.filter(contains(subject, "2"))
|> Ash.DataLayer.Simple.set_data(tickets)
|> Helpdesk.Support.read!()

# Show the tickets that are closed and their subject does not contain "4"
Helpdesk.Support.Ticket
|> Ash.Query.filter(status == :closed and not(contains(subject, "4")))
|> Ash.DataLayer.Simple.set_data(tickets)
|> Helpdesk.Support.read!()
```
Notice the power of the `filter` command, try adjusting.

To learn more visit:
* [Ash Queries](https://www.ash-hq.org/docs/module/ash/2.4.1/ash-query)
* [Writing an Ash Filter](https://www.ash-hq.org/docs/module/ash/2.4.1/ash-filter)


## Ash Persistence (ETS)

ETS is an in-memory (OTP based) way to persist data (we will work with PostgreSQL later).
Once we have persisted data we can explore relationships.

To add ETS to the Data Layer we need to change the line `use Ash.Resource` to:
```elixir
# lib/helpdesk/support/resources/ticket.ex
  # ...
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets
  # ...
```
Now the file should look like:
```elixir
# lib/helpdesk/support/resources/ticket.ex
defmodule Helpdesk.Support.Ticket do
  # This turns this module into a resource
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  actions do
    # Add a set of simple actions. You'll customize these later.
    defaults [:create, :read, :update, :destroy]

    create :new do
      accept [:subject] # only accept the subject - no other fields
    end

    update :close do
      accept [] # don't accept attributes
      change set_attribute(:status, :closed) # build the change set
    end
  end

    # Attributes are the simple pieces of data that exist on your resource
  attributes do
    # Add an autogenerated UUID primary key called `:id`.
    uuid_primary_key :id

    # Add a string type attribute called `:subject`
    attribute :subject, :string do
      allow_nil? false # Don't allow `nil` values
    end

    # status is either `open` or `closed`. We can add more statuses later
    attribute :status, :atom do
      # restricted list of statuses
      constraints [one_of: [:new, :open, :closed]]
      default :new # default value when none is given
      allow_nil? false # Don't allow `nil` values
    end
  end
end
```

Let's be sure our new data layer is working:
```elixir
iex -S mix
# and or
recompile()

require Ash.Query

for i <- 0..5 do
  ticket =
    Helpdesk.Support.Ticket
    |> Ash.Changeset.for_create(:new, %{subject: "Issue #{i}"})
    |> Helpdesk.Support.create!()

  if rem(i, 2) == 0 do
    ticket
    |> Ash.Changeset.for_update(:close)
    |> Helpdesk.Support.update!()
  end
end

# Show the tickets where the subject contains "2"
Helpdesk.Support.Ticket
|> Ash.Query.filter(contains(subject, "2"))
|> Helpdesk.Support.read!()

# Show the tickets that are closed and their subject does not contain "4"
Helpdesk.Support.Ticket
|> Ash.Query.filter(status == :closed and not(contains(subject, "4")))
|> Helpdesk.Support.read!()
```

## Ash Relationships

We will now create a `User` that can create or be assigned a ticket (using ETS as the data layer).

```elixir
# lib/helpdesk/support/resources/user.ex
defmodule Helpdesk.Support.User do
  # This turns this module into a resource
  use Ash.Resource,
    data_layer: Ash.DataLayer.Ets

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  attributes do
    uuid_primary_key :id
    attribute :name, :string
  end

  relationships do
    has_many :assigned_tickets, Helpdesk.Support.Ticket do
      destination_attribute :representative_id
    end
    has_many :reported_tickets, Helpdesk.Support.Ticket do
      destination_attribute :reporter_id
    end
  end
end
```
The `has_many` means that the destination attribute is not unique, meaning many related records could exist.


We also need to register our new `user` resource by adding:
```elixir
# lib/helpdesk/support/registry.ex
  entries do
    # ...
    entry Helpdesk.Support.User
  end
```

So now our registry should look like:
```elixir
# lib/helpdesk/support/registry.ex
defmodule Helpdesk.Support.Registry do
  use Ash.Registry,
    extensions: [
      Ash.Registry.ResourceValidations
    ]

  entries do
    entry Helpdesk.Support.Ticket
    entry Helpdesk.Support.User
  end
end
```

Now we need to add the relationship to Tickets too:
```elixir
# lib/helpdesk/support/resources/ticket.ex
  # ...
  relationships do
    belongs_to :reporter, Helpdesk.Support.User
    belongs_to :representative, Helpdesk.Support.User
  end
  # ...
```
We use `belong_to` meaning that the destination attribute is unique, meaning only one related record could exist.

Now we need to create additional 'actions' for ticket to manage the relationships:
```elixir
# lib/helpdesk/support/resources/ticket.ex
  actions do
    # Add a set of simple actions. You'll customize these later.
    defaults [:create, :read, :update, :destroy]

    create :new do
      accept [:subject]

      argument :reporter_id, :uuid do
        allow_nil? false # This action requires reporter_id
      end

      change manage_relationship(:reporter_id, :reporter, type: :append_and_remove)
    end

    update :assign do
      # No attributes should be accepted
      accept []
      # We accept a representative's id as input here
      argument :representative_id, :uuid do
        # This action requires representative_id
        allow_nil? false
      end
      # We use a change here to replace the related representative
      change manage_relationship(:representative_id, :representative, type: :append_and_remove)
    end

    update :start do
      # No attributes should be accepted
      accept []
      # We accept a representative's id as input here
      argument :representative_id, :uuid do
        # This action requires representative_id
        allow_nil? false
      end
      # We use a change here to replace the related representative
      change manage_relationship(:representative_id, :representative, type: :append_and_remove)
      change set_attribute(:status, :open)
    end

    update :close do
      # We don't want to accept any input here
      accept []
      change set_attribute(:status, :closed)
    end
  # ...
```

We can learn more about managing ash relationships at: https://www.ash-hq.org/docs/module/ash/2.4.1/ash-resource-change-builtins#function-manage_relationship-3


Testing Relationships:
```elixir
iex -S mix
#
recompile()

# Create a reporter
reporter = (
  Helpdesk.Support.User
  |> Ash.Changeset.for_create(:create, %{name: "Nyima Dog"})
  |> Helpdesk.Support.create!()
)

# Open a ticket
ticket = (
  Helpdesk.Support.Ticket
  |> Ash.Changeset.for_create(:new, %{subject: "I can't find my hand!", reporter_id: reporter.id})
  |> Helpdesk.Support.create!()
)

# Create a representative
representative_joe = (
  Helpdesk.Support.User
  |> Ash.Changeset.for_create(:create, %{name: "Joe"})
  |> Helpdesk.Support.create!()
)

representative_jose = (
  Helpdesk.Support.User
  |> Ash.Changeset.for_create(:create, %{name: "Jose"})
  |> Helpdesk.Support.create!()
)

# Assign that representative
ticket = (
  ticket
  |> Ash.Changeset.for_update(:assign, %{representative_id: representative_joe.id})
  |> Helpdesk.Support.update!()
)

# Start working on the Ticket
ticket = (
  ticket
  |> Ash.Changeset.for_update(:start, %{representative_id: representative_jose.id})
  |> Helpdesk.Support.update!()
)

# close the ticket
ticket = (
  ticket
    |> Ash.Changeset.for_update(:close)
    |> Helpdesk.Support.update!()
)
```

## Ash Postgres -- Configure

My goal here was to configure Ash so that a pre-existing Phoenix Ecto Repo would keep working and Ash would work along side it.

Here is what I did (a deeper dive into: https://github.com/ash-project/ash_postgres/blob/main/documentation/tutorials/get-started-with-postgres.md)

We will make a new Ash Repo:
```elixir
# lib/helpdesk/support/repo.ex
defmodule Support.Repo do
  use AshPostgres.Repo, otp_app: :helpdesk
end
```

Now tell Phoenix Config:
```elixir
# config/config.exs
import Config

# add Ash APIs to config
config :helpdesk,
  ash_apis: [Helpdesk.Support]

config :helpdesk,
  ecto_repos: [
    Support.Repo, # add newly created Support Repo
    Helpdesk.Repo
  ]
# ...
```

In the `config/dev.exs` config add the Support database config alongside the Phoenix Ecto config:
```elixir
# config/dev.exs
import Config

# Phoenix Dev DB config
config :helpdesk, Helpdesk.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "helpdesk_dev",
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10

# Ash dev DB Config
config :helpdesk, Support.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "support_dev",
  stacktrace: true,
  show_sensitive_data_on_connection_error: true,
  pool_size: 10
# ...
```

Update `config/test.exs` database settings with:
```elixir
# config/test.exs
import Config

# Configure your phoenix database
config :helpdesk, Helpdesk.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "helpdesk_test#{System.get_env("MIX_TEST_PARTITION")}",
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: 10
# Configure your ash (support) database
config :helpdesk, Support.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "support_test#{System.get_env("MIX_TEST_PARTITION")}",
  pool: Ecto.Adapters.SQL.Sandbox,
  pool_size: 10
# ...
```

Finally, update `config/runtime.exs` with (note I haven't deployed - so this is untested):
```elixir
# config/runtime.exs
import Config

if System.get_env("PHX_SERVER") do
  config :helpdesk, HelpdeskWeb.Endpoint, server: true
end

if config_env() == :prod do
  support_database_url =
    System.get_env("SUPPORT_DATABASE_URL") ||
      raise """
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      """
  phoenix_database_url =
    System.get_env("PHOENIX_DATABASE_URL") ||
      raise """
      environment variable DATABASE_URL is missing.
      For example: ecto://USER:PASS@HOST/DATABASE
      """

  maybe_ipv6 = if System.get_env("ECTO_IPV6"), do: [:inet6], else: []

  config :helpdesk, Support.Repo,
    # ssl: true,
    url: support_database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
    socket_options: maybe_ipv6

  config :helpdesk, Helpdesk.Repo,
    # ssl: true,
    url: phoenix_database_url,
    pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10"),
    socket_options: maybe_ipv6
# ...
```

Hopefully you can start `iex -S mix`

## Ash Postgres -- Usage

Now we need to tell our `resources` about our new `Support.Repo`, we will do this in the 'ticket' and 'user' files -- we will replace `use Ash.Resource, data_layer: Ash.DataLayer.Ets` with:

```elixir
# lib/helpdesk/support/resources/ticket.ex
defmodule Helpdesk.Support.Ticket do
  use Ash.Resource,
    data_layer: AshPostgres.DataLayer

  postgres do
    table "tickets"
    repo Support.Repo
  end
# ...
```

and
```elixir
# lib/helpdesk/support/resources/user.ex

defmodule Helpdesk.Support.User do
  use Ash.Resource,
    data_layer: AshPostgres.DataLayer

  postgres do
    table "users"
    repo Support.Repo
  end
# ...
```

Now we should be able to create the 'Support' database with:
```bash
mix ash_postgres.create
```

If you get an --apis error then you probably forgot the API config in `config/config.exs` try adding:
```elixir
# config/config.exs
import Config

config :helpdesk,
  ash_apis: [Helpdesk.Support]

# ...
```

Assuming this worked now you can generate a migration from existing 'resources' with:
```elixir
mix ash_postgres.generate_migrations --name support_add_tickets_and_users
```

This should create a migration that looks like:
```elixir
# priv/repo/migrations/YYYYMMDDHHmmSS_support_add_tickets_and_users.exs
defmodule Support.Repo.Migrations.SupportAddTicketsAndUsers do
  use Ecto.Migration

  def up do
    create table(:users, primary_key: false) do
      add :id, :uuid, null: false, primary_key: true
      add :name, :text
    end

    create table(:tickets, primary_key: false) do
      add :id, :uuid, null: false, primary_key: true
      add :subject, :text, null: false
      add :status, :text, null: false, default: "open"
      add :reporter_id,
          references(:users,
            column: :id,
            name: "tickets_reporter_id_fkey",
            type: :uuid,
            prefix: "public"
          )
      add :representative_id,
          references(:users,
            column: :id,
            name: "tickets_representative_id_fkey",
            type: :uuid,
            prefix: "public"
          )
    end
  end

  def down do
    drop constraint(:tickets, "tickets_representative_id_fkey")
    drop constraint(:tickets, "tickets_reporter_id_fkey")
    drop table(:tickets)
    drop table(:users)
  end
end
```

Finally we can update the database by migrating using:
```bash
mix ash_postgres.migrate
```

TESTING: Ideally now all our previous tests should still work:
```elixir
iex -S mix
# and or
recompile()

require Ash.Query

for i <- 0..5 do
  ticket =
    Helpdesk.Support.Ticket
    |> Ash.Changeset.for_create(:new, %{subject: "Issue #{i}"})
    |> Helpdesk.Support.create!()

  if rem(i, 2) == 0 do
    ticket
    |> Ash.Changeset.for_update(:close)
    |> Helpdesk.Support.update!()
  end
end

# Show the tickets where the subject contains "2"
Helpdesk.Support.Ticket
|> Ash.Query.filter(contains(subject, "2"))
|> Helpdesk.Support.read!()

# Show the tickets that are closed and their subject does not contain "4"
Helpdesk.Support.Ticket
|> Ash.Query.filter(status == :closed and not(contains(subject, "4")))
|> Helpdesk.Support.read!()
```
